% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{타}{입과 순수 함수를 카테고리로} 모델링하는 방법을 살펴 보았습니다.
또한 카테고리 이론에서 부작용이나 순수하지 않은 함수를 모델링하는 방법이 있다고 언급했습니다.
실행을 기록하거나 추적하는 함수와 같은 하나의 예를 살펴 보겠습니다. 명령형 언어에서는 다음과
같이 전역 상태를 변경하여 구현할 수 있습니다:

\begin{snip}{cpp}
string logger;

bool negate(bool b) {
    logger += "Not so! ";
    return !b;
}
\end{snip}
이를 메모하여 사용하면 로그를 생성하지 못하기 때문에 순수한 함수가 아니라는걸 알 수 있습니다.
이 함수는 \newterm{부작용}이 있습니다.

최근의 프로그래밍에서는 복잡한 동시성 제어와 함께 변경 가능한 한 전역 상태를 사용하는 것을
피해야 합니다. 아무도 이런 코드를 라이브러리에 결코 넣고 싶지 않겠죠.

다행히 우리는 이 함수를 순수하게 만들 수 있습니다. 로그를 명시적으로 안팎으로 전달하면 됩니다.
문자열 인수를 추가하고 원래의 결과를 업데이트 된 로그를 포함한 문자열과 함께 출력하는걸 수행
하십시오:

\begin{snip}{cpp}
pair<bool, string> negate(bool b, string logger) {
    return make_pair(!b, logger + "Not so! ");
}
\end{snip}
이 함수는 순수하고 부작용이 없으며 동일한 인수의 호출에 동일한 결과를 반환하며 필요하다면 메모
할 수 있습니다. 그러나 로그를 누적하기 때문에 앞서 호출된 모든 가능한 기록을 메모해야 합니다.
다음과 같은 별도의 메모 항목이 있습니다:

\begin{snip}{cpp}
negate(true, "It was the best of times. ");
\end{snip}
그리고

\begin{snip}{cpp}
negate(true, "It was the worst of times. ");
\end{snip}
이런 식이죠.

또한 라이브러리로 쓰이기엔 훌륭한 인터페이스가 아닙니다. 호출하는 쪽에서 원하면 반환된 문자열을
무시할 수 있으므로 큰 부담이 되지 않습니다. 그러나 문자열을 입력으로 전달해야 하므로 불편할 수
있습니다.

이와같은 일을 좀 더 수월하게 해결 할 수 없을까요? 관심사를 분리해 보는 건 어떨까요? 이 간단한
예제에서 함수 negate 의 주요 목적은 주어진 불리언 값을 다른 불리언 값으로 바꾸는 것입니다.
로깅은 보조입니다. 물론, 기록되는 메시지는 함수와 관련이 있지만 메시지를 하나의 연속 로그로
집계하는 작업은 별도의 문제입니다. 여전히 함수가 문자열을 생성하기를 원하지만 로그를 생성하지
않도록 합시다. 타협의 방법은 다음과 같습니다:

\begin{snip}{cpp}
pair<bool, string> negate(bool b) {
    return make_pair(!b, "Not so! ");
}
\end{snip}
아이디어는 함수 호출 \emph{사이에} 로그가 집계된다는 것입니다.

이 작업을 수행하는 방법을 알아보기 위해 좀 더 현실적인 예를 들어보겠습니다. 문자열에서 소문자를
대문자로 바꾸는 함수가 하나 있습니다:

\begin{snip}{cpp}
string toUpper(string s) {
    string result;
    int (*toupperp)(int) = &toupper; // toupper is overloaded
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return result;
}
\end{snip}
그리고 문자열을 공백을 기준으로 나눠 문자열 벡터로 만드는 함수도 있습니다:

\begin{snip}{cpp}
vector<string> toWords(string s) {
    return words(s);
}
\end{snip}
실제 작업은 words 라는 보조 함수에서 수행합니다.

\begin{snip}{cpp}
vector<string> words(string s) {
    vector<string> result{""};
    for (auto i = begin(s); i != end(s); ++i)
    {
        if (isspace(*i))
            result.push_back(""); 
        else
            result.back() += *i;
    }
    return result;
}
\end{snip}
이제 문자열을 위의 \code{toUpper} 함수와 \code{toWords} 함수로 변경한 결과를
반환값으로 전송하려 합니다.

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{images/piggyback.jpg}
\end{figure}
\noindent
이 함수들의 반환 값을 "꾸밀" 수 있습니다. 일반적으로 임의의 값 \code{A}와 문자열의 쌍으로
캡슐화하는 템플릿 \code{Writer}를 정의하는 방식으로 수행합니다:

\begin{snip}{cpp}
template<class A>
using Writer = pair<A, string>;
\end{snip}
여기 꾸며진 함수들이 있습니다:

\begin{snip}{cpp}
Writer<string> toUpper(string s) {
    string result;
    int (*toupperp)(int) = &toupper;
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return make_pair(result, "toUpper "); 
}

Writer<vector<string>> toWords(string s) { 
    return make_pair(words(s), "toWords ");
}
\end{snip}
이 두 함수를 결합하여 문자열을 대문자로 만들고 단어로 분할하는 다른 꾸며진 함수를 만들어 봅시다.
그 방법은 다음과 같습니다:

\begin{snip}{cpp}
Writer<vector<string>> process(string s) {
    auto p1 = toUpper(s);
    auto p2 = toWords(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
\end{snip}
이 정도면 충분합니다. 로그를 쌓는 것은 더 이상 이 함수들의 관심사가 아닙니다. 각 함수가 각자의
메시지를 생성하면, 그것을 외부에서 전체 로그에 쌓아갑니다.

이제 이런 방식으로 작성된 전체 프로그램을 상상해보십시오. 그것은 끔찍할만큼 반복적이고 오류가
발생하기 쉬운 코드일 겁니다. 프로그래머라면 이러한 반복적인 코드를 다루는 방법을 알고 있죠:
바로 추상화입니다. 밀 추상화(?)를 말하는 것은 아닙니다. \newterm{함수 합성} 자체를 추상화
할 수 있습니다. 합성은 카테고리 이론의 핵심이므로 더 많은 코드를 보기 전에 카테고리 관점에서
문제를 분석해 보겠습니다.

\section{The Writer Category}

추가적인 기능을 덧대기 위해 여러 함수들의 반환 값을 꾸며가는 아이디어는 매우 유익합니다. 
더 많은 예를 볼 수 있습니다. 그 시작은 타입과 함수의 정칙 카테고리부터 입니다. 타입은
객체로 남겨두고, 사상을 꾸며진 함수라고 생각해 봅시다.

예를 들어, \code{int}에서 \code{bool}로 이동하는 \code{isEven} 함수를 로그와
함께 반환하도록 꾸며봅시다. 여기서 중요한 점은 이 변경된 함수가 결과 값으로 쌍을 반환한다
하더라도 \code{int}와 \code{bool} 객체 사이의 화살표로 간주된다는 것입니다:

\begin{snip}{cpp}
pair<bool, string> isEven(int n) {
    return make_pair(n % 2 == 0, "isEven ");
}
\end{snip}
카테고리 규칙에 따라 객체 \code{bool}에서 어떤 형태로의 사상과도 합성 할 수 있습니다.
마찬가지로 앞서 다룬 \code{negate} 함수와도 합성할 수 있지요:

\begin{snip}{cpp}
pair<bool, string> negate(bool b) {
    return make_pair(!b, "Not so! ");
}
\end{snip}
당장 연결할 두 사상을 합성하려면 연결에 필요한 입출력이 맞지 않아 일반적으로 함수를 합성하는
방식으로는 합성할 수 없습니다. 이 경우는 다음과 같이 합성합니다:

\begin{snip}{cpp}
pair<bool, string> isOdd(int n) {
    pair<bool, string> p1 = isEven(n);
    pair<bool, string> p2 = negate(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
\end{snip}
다음은 새로운 카테고리를 활용하여 두 가지 사상을 합성하는 레시피입니다:

\begin{enumerate}
\tightlist
\item
  일단 꾸며진 함수 중 첫 번째 사상에 해당하는 함수를 실행
\item
  그 결과인 쌍에서 첫 번째 요소를 꾸며진 함수 중 두 번째 사상에 해당하는 함수에 전달
\item
  각 두 결과의 두 번째 요소(문자열)들을 연결
\item
  최종 결과와 연결된 문자열의 쌍으로 반환
\end{enumerate}

이 합성을 C++ 에서 고차 함수로 추상화 한다면 세 종류의 카테고리에 해당하는 세 가지 타입
매개변수로 이뤄진 템플릿을 사용할 수 있습니다. 앞선 레시피대로 합성 가능한 두 함수를 받아
새로운 함수를 반환해야 합니다:

\begin{snip}{cpp}
template<class A, class B, class C>
function<Writer<C>(A)> compose(function<Writer<B>(A)> m1,
                               function<Writer<C>(B)> m2)
{
    return [m1, m2](A x) {
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second); 
    };
}
\end{snip}
이제 이전 예제로 돌아가서 방금 만든 새 템플릿을 사용하면 \code{toUpper}와
\code{toWords}도 합성할 수 있습니다:

\begin{snip}{cpp}
Writer<vector<string>> process(string s) { 
    return compose<string, string, vector<string>>(toUpper, toWords)(s);
}
\end{snip}
이 \code{compose} 템플릿을 사용할 때 타입과 관련한 여러 걱정들이 예상됩니다. 만약 람다
함수를 지원하는 C++14 호환 컴파일러를 사용한다면 걱정들을 상당히 줄일 수 있습니다.
(이제 이 코드의 신뢰는 Eric Niebler 가 책임지기로 하죠):

\begin{snip}{cpp}
auto const compose = [](auto m1, auto m2) { 
    return [m1, m2](auto x) { 
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second);
    };
};
\end{snip}
이렇게 하면 \code{process} 함수의 구현은 더 간단해집니다:

\begin{snip}{cpp}
Writer<vector<string>> process(string s) {
    return compose(toUpper, toWords)(s);
}
\end{snip}
그러나 아직 더 생각할 것이 있습니다. 우리는 새로운 카테고리를 써서 합성을 만들었지만
이 합성에 항등원은 어떻게 될까요? 항등함수라면 A 타입에서 A 타입으로 사상해야 합니다.
우리가 꾸며온 함수들의 타입은 다음과 같습니다:

\begin{snip}{cpp}
Writer<A> identity(A);
\end{snip}
이 합성을 만족시키는 항등 사상은 전달된 인수는 변경하지 않고 다시 결과에 전달하며 로그는
영향이 없는 빈 문자열만 연산하는 두 행동을 함께 만족해야 합니다:

\begin{snip}{cpp}
template<class A> Writer<A> identity(A x) {
    return make_pair(x, "");
}
\end{snip}
이렇게 만든 카테고리가 카테고리로 정의하기에 필요한 조건들을 충분히 만족한다는 것을 쉽게
증명할 수 있습니다. 먼저, 이 합성이 띄는 결합성을 쉽게 확인할 수 있습니다. 각 결과 쌍의
첫 번째 요소들만 주목해서 따라가보면 일반적인 함수의 합성일 뿐이며 결합성을 보입니다.
두 번째 요소들도 계속 쌓여가고 이 동작도 결합성을 보입니다.

눈치빠른 독자라면 이 문자열 모노이드 구조가 모든 모노이드로 일반화하기 쉽다는 것을
눈치 챘을지도 모릅니다. \code{compose} 역할로 \code{mappend}를 사용하고
\code{identity}는 \code{mempty}로 표현할 수 있습니다(\code{+} 및 \code{""}).
이 기능이 문자열을 로깅하는 것으로만 제한할 이유가 없습니다. 우수한 라이브러리 작성자라면
라이브러리가 작동할 수 있는 최소한의 제약 조건을 식별 할 수 있어야합니다. 여기서 로깅
라이브러리의 유일한 조건은 로그가 모노이드 성격을 띄는 것입니다.

\section{Writer in Haskell}

동일한 내용dmf Haskell은 컴파일러의 도움을 받아 좀 더 간결하게 표현할 수 있습니다.
\code{Writer} 유형을 정의하는 것으로 시작합니다.

\src{snippet01}
C++ 의 \code{typedef} (또는 \code{using})와 비슷하게 타입의 alias 를
정의하고 있습니다. 파라미터로 타입 변수 \code{a}를 받은 \code{Writer} 타입은
\code{a}와 \code{String} 쌍과 동등합니다. 괄호 안에 두 항목을 쉼표로 구분해서 쓰는
쌍에 대한 표현은 정말 간단합니다.

아래 사상은 임의의 타입을 \code{Writer} 타입에 대응하는 함수입니다:

\src{snippet02}
이런 합성을 나타내는 이른바 ``물고기''라고 불리는 재미있는 연산자가 있습니다:

\src{snippet03}
위 함수는 두 개의 함수를 인자로 받아 역시 함수를 반환합니다. 첫번째 인자는
\code{(a -> Writer b)} 타입이고, 두번째 인자는 \code{(b -> Writer c)} 타입이며,
그 결과는 \code{(a -> Writer c)} 타입입니다.

이 연산자의 정의는 다음과 같습니다. --- 물고기 기호의 양쪽에 나타나는 두 개의 인수
\code{m1}와 \code{m2}:

\src{snippet04}
결과는 하나의 인수 \code{x}를 받는 람다 함수입니다. 람다는 백슬래시로 표현합니다. ---
다리가 하나가 잘린 그리스 문자 λ를 떠올려보세요.

\code{let} 표현식을 사용하면 보조 변수를 선언 할 수 있습니다. 여기서 \code{m1}
호출의 결과는 \code{(y, s1)} 쌍과 일치하는 패턴입니다. 첫 번째 패턴에서 인수
\code{y}를 받는 \code{m2}에 대한 호출 결과는 \code{(z, s2)} 쌍과 일치합니다.

C++ 에서 접근자를 사용하는 대신 Haskell 에서는 쌍의 패턴 매치를 사용하는 방식이
일반적입니다. 이렇게 구현해본 본 두 결과는 매우 흡사합니다.

\code{let} 표현식의 주요한 내용은 \code{in} 절에 적습니다.
결과 쌍의 첫 번째 요소는 \code{z}이고 두 번째 요소는 두 개의 문자열을
\code{s1 ++ s2} 로 연결한 것입니다.

또한 다음처럼 카테고리에 대한 항등 사상을 정의하고, 나중에 좀 더 알아볼테지만 일단은
\code{return}이라고 부르겠습니다.

\src{snippet05}
완성도를 높이기 위해 Haskell 버전으로 작성된 함수 \code{upCase} 및
\code{toWords}도 작성해 보겠습니다:

\src{snippet06}
\code{map} 함수는 C++ 의 \code{transform}에 해당합니다. \code{toUpper}
함수를 문자열 \code{s}에 적용합니다. \code{words} 함수는 표준 Prelude 라이브러리에
있습니다.

마지막으로, 두 함수의 합성은 물고기 연산자의 도움을 받아 완성합니다:

\src{snippet07}

\section{Kleisli Categories}

제가 이 카테고리를 즉흥적으로 생각해 낸 것으로 보이지는 않겠죠. 이 예시는 모나드를
기반으로 한 Kleisli 카테고리 입니다. 우리는 아직 모나드에 대해 논의 할 준비가 되지
않았지만, 모나드로 할 수 있는 것을 살짝 보여주고 싶었습니다. 여기서는 제한적으로
사용하였지만 Kleisli 카테고리는 프로그래밍 언어의 기반을 이루는 객체나 그 타입을 나타낼
수 있습니다. 타입 $A$에서 타입 $B$ 로의 사상은 $A$ 로 시작하여 $B$ 에서 파생하는
타입으로 이동하는 과정을 장식하는 함수들 입니다.

각 Kleisli 카테고리는 항등 사상을 포함한 이러한 사상들의 합성하는 방법을 정의합니다.
(``장식''이라는 부정확한 용어는 카테고리 이론에서 endofunctor의 개념에 해당합니다.)

The particular monad that I used as the basis of the category in this
post is called the \newterm{writer monad} and it's used for logging or
tracing the execution of functions. It's also an example of a more
general mechanism for embedding effects in pure computations. You've
seen previously that we could model programming-language types and
functions in the category of sets (disregarding bottoms, as usual). Here
we have extended this model to a slightly different category, a category
where morphisms are represented by embellished functions, and their
composition does more than just pass the output of one function to the
input of another. We have one more degree of freedom to play with: the
composition itself. It turns out that this is exactly the degree of
freedom which makes it possible to give simple denotational semantics to
programs that in imperative languages are traditionally implemented
using side effects.

\section{Challenge}

A function that is not defined for all possible values of its argument
is called a partial function. It's not really a function in the
mathematical sense, so it doesn't fit the standard categorical mold. It
can, however, be represented by a function that returns an embellished
type \code{optional}:

\begin{snip}{cpp}
template<class A> class optional {
    bool _isValid;
    A _value;
public: 
    optional()    : _isValid(false) {}
    optional(A v) : _isValid(true), _value(v) {}
    bool isValid() const { return _isValid; }
    A value() const { return _value; }
};
\end{snip}
For example, here's the implementation of the embellished function
\code{safe\_root}:

\begin{snip}{cpp}
optional<double> safe_root(double x) {
    if (x >= 0) return optional<double>{sqrt(x)}; 
    else return optional<double>{};
}
\end{snip}
Here's the challenge:

\begin{enumerate}
\tightlist
\item
  Construct the Kleisli category for partial functions (define
  composition and identity).
\item
  Implement the embellished function \code{safe\_reciprocal} that
  returns a valid reciprocal of its argument, if it's different from
  zero.
\item
  Compose the functions \code{safe\_root} and \code{safe\_reciprocal} to implement
  \code{safe\_root\_reciprocal} that calculates \code{sqrt(1/x)}
  whenever possible.
\end{enumerate}
